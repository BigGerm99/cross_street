#!/usr/bin/env python3

from __future__ import print_function

import sys
import rospy
from cross_check.srv import *
from cv_bridge import CvBridge

import torch
from torchvision.transforms import ToTensor
import time
from lyt.LYTNet import LYTNet
from lyt.LYTNetV2 import LYTNetV2
import cv2
import numpy as np
from PIL import Image

import warnings

warnings.filterwarnings("ignore")

bridge = CvBridge()
net = LYTNetV2()
MODEL_PATH = '/home/germ/ros_catkin_ws/src/cross_check/src/lyt/TrainingResult/TrainingResult-V2-200/_final_weights'
checkpoint = torch.load(MODEL_PATH)
net.load_state_dict(checkpoint)
net.eval()
trans = torchvision.transforms.ToTensor()
 

def usage():
    return "%s [x]"%sys.argv[0]

def response_check(x):
    rospy.wait_for_service('camera_lyt')
    try:
        recieve_image = rospy.ServiceProxy('camera_lyt', AskImage)
        resp1 = recieve_image(x)
        orig = bridge.imgmsg_to_cv2(resp1.Image, "bgr8")
        return 
    except rospy.ServiceException as e:
        print("Service call failed: %s"%e)

def guess(orig):
    image = cv2.cvtColor(orig, cv2.COLOR_BGR2RGB)
    img = Image.fromarray(image)

    plt.imshow(img)

    img = trans(img).unsqueeze(0)
    img = img.type(torch.FloatTensor)
    img = img * 255

    print(img[0][0])

    with torch.no_grad():
        if cuda_available:
            img = img.cuda()

        pred_classes, pred_direc = net(img)
        _, predicted = torch.max(pred_classes, 1)
        print(predicted)


if __name__ == "__main__":
    if len(sys.argv) == 2:
        x = int(sys.argv[1])
    else:
        print(usage())
        sys.exit(1)
    print(response_check(x))
    
